using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveLisp.Core.BuiltIns.TypesAndClasses
{
    /*
     * каждый раз когда синтаксически ожидается имя типа строиться этот объект.
     * 
     * Выяснение конкретного типа по имени:
     * 1) Поиск по CLOS классам заданным пользователем
     * 2) Если 1) неудачен то поиск .NET типов.
     *      ввиду повышенного содержания точек (а значит и длинны имени) встаёт вопрос об организации 
     *      разрешения имён.
     *      
     *      для разрешения дот-нет типов используется только имя символа т.е. неважно из каких
     *      пакетов символы - если они имеют одинаковое имя они будут разрешаться в один тип.
     *      
     *      так же используется "пространства имен" - непозрозрачно по отношению к TypeName
     * 
     *      после определения дот нет тип упаковывается в обёртку 
     *      обёртка ассоцируется с типом
     * 
     * 3) Если и дотнет тип не найден - ошибка
     */


    /// <summary>
    /// потомки этого класса переопределяют метод Match
    /// так, что можно разрешать типы (values ... ) (or ...) (and ...) (eq ...) и прочие
    /// </summary>
    public abstract class TypeName
    {
        public abstract bool Match(object obj);
    }
}
